<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL::SYNC // KURAMOTO CORTICAL MONITOR v2.7.1</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Terminal';
            src: local('Courier New');
        }
        
        :root {
            --bg-black: #000000;
            --bg-dark: #050508;
            --terminal-cyan: #00ffff;
            --terminal-cyan-dim: #007a7a;
            --terminal-cyan-glow: rgba(0, 255, 255, 0.4);
            --warning-red: #ff3344;
            --warning-red-dim: #661122;
            --alert-yellow: #ffcc00;
            --success-green: #00ff66;
            --grid-color: rgba(0, 255, 255, 0.08);
            --scanline-color: rgba(0, 0, 0, 0.15);
            --text-primary: #00ffff;
            --text-dim: #006666;
            --text-white: #ffffff;
            --border-glow: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(0, 255, 255, 0.2);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            font-family: 'IBM Plex Mono', 'Courier New', monospace;
            background: var(--bg-black);
            color: var(--text-primary);
            overflow-x: hidden;
            min-height: 100vh;
            font-size: 12px;
            letter-spacing: 0.05em;
        }
        
        /* ===== CRT EFFECTS ===== */
        .crt-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
        }
        
        .crt-overlay::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                var(--scanline-color) 2px,
                var(--scanline-color) 4px
            );
            animation: scanlines 0.1s linear infinite;
        }
        
        .crt-overlay::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.3) 100%);
        }
        
        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 4px; }
        }
        
        /* ===== CROSS GRID BACKGROUND ===== */
        .cross-grid {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }
        
        .cross-grid::before {
            content: '';
            position: absolute;
            inset: -50px;
            background-image: 
                radial-gradient(circle at center, var(--grid-color) 1px, transparent 1px);
            background-size: 40px 40px;
            background-position: 20px 20px;
        }
        
        .cross-grid::after {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                linear-gradient(90deg, transparent 19px, var(--grid-color) 19px, var(--grid-color) 21px, transparent 21px),
                linear-gradient(0deg, transparent 19px, var(--grid-color) 19px, var(--grid-color) 21px, transparent 21px);
            background-size: 40px 40px;
            opacity: 0.3;
        }
        
        /* Plus signs grid */
        .plus-grid {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M19 8v8h-8v2h8v8h2v-8h8v-2h-8V8h-2z' fill='%23007a7a' fill-opacity='0.15'/%3E%3C/svg%3E");
            background-size: 40px 40px;
        }
        
        /* ===== HEADER ===== */
        header {
            position: relative;
            z-index: 10;
            padding: 12px 20px;
            border-bottom: 1px solid var(--terminal-cyan-dim);
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .logo-mark {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .logo-mark span {
            display: block;
            height: 3px;
            background: var(--warning-red);
        }
        
        .logo-mark span:nth-child(1) { width: 20px; }
        .logo-mark span:nth-child(2) { width: 15px; margin-left: 5px; }
        .logo-mark span:nth-child(3) { width: 20px; }
        .logo-mark span:nth-child(4) { width: 10px; margin-left: 10px; }
        
        .system-title {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.3em;
            text-transform: uppercase;
        }
        
        .system-title .highlight {
            color: var(--warning-red);
        }
        
        .system-subtitle {
            font-size: 9px;
            color: var(--text-dim);
            letter-spacing: 0.2em;
            margin-top: 2px;
        }
        
        .header-stats {
            display: flex;
            gap: 30px;
            align-items: center;
        }
        
        .stat-block {
            text-align: right;
        }
        
        .stat-label {
            font-size: 8px;
            color: var(--text-dim);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        
        .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--terminal-cyan);
            font-family: 'Space Mono', monospace;
        }
        
        .stat-value.warning {
            color: var(--warning-red);
            animation: blink 1s ease-in-out infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border: 1px solid var(--success-green);
            background: rgba(0, 255, 102, 0.05);
        }
        
        .status-dot {
            width: 6px;
            height: 6px;
            background: var(--success-green);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 5px var(--success-green); }
            50% { opacity: 0.5; box-shadow: none; }
        }
        
        .status-text {
            font-size: 9px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--success-green);
        }
        
        /* ===== MAIN LAYOUT ===== */
        .main-container {
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            gap: 1px;
            background: var(--terminal-cyan-dim);
            min-height: calc(100vh - 60px);
        }
        
        /* ===== PANELS ===== */
        .panel {
            background: var(--bg-black);
            position: relative;
        }
        
        .panel-header {
            padding: 10px 15px;
            border-bottom: 1px solid var(--terminal-cyan-dim);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 255, 255, 0.02);
        }
        
        .panel-title {
            font-size: 9px;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            color: var(--terminal-cyan);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-title::before {
            content: '//';
            color: var(--warning-red);
        }
        
        .panel-id {
            font-size: 8px;
            color: var(--text-dim);
            font-family: 'Space Mono', monospace;
        }
        
        .panel-content {
            padding: 15px;
        }
        
        /* ===== CROSSHAIR DECORATIONS ===== */
        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: var(--terminal-cyan);
        }
        
        .crosshair::before {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
        }
        
        .crosshair::after {
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
        }
        
        .crosshair.top-left { top: 10px; left: 10px; }
        .crosshair.top-right { top: 10px; right: 10px; }
        .crosshair.bottom-left { bottom: 10px; left: 10px; }
        .crosshair.bottom-right { bottom: 10px; right: 10px; }
        
        /* ===== CONTROLS PANEL ===== */
        .controls-panel {
            overflow-y: auto;
            max-height: calc(100vh - 60px);
        }
        
        .control-section {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .section-marker {
            width: 3px;
            height: 12px;
            background: var(--warning-red);
        }
        
        .section-title {
            font-size: 9px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--text-dim);
        }
        
        /* ===== SLIDER CONTROLS ===== */
        .slider-group {
            margin-bottom: 18px;
        }
        
        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 8px;
        }
        
        .slider-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-primary);
        }
        
        .slider-value {
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            color: var(--terminal-cyan);
            text-shadow: 0 0 10px var(--terminal-cyan-glow);
        }
        
        .slider-track {
            position: relative;
            height: 20px;
            display: flex;
            align-items: center;
        }
        
        input[type="range"] {
            width: 100%;
            height: 2px;
            -webkit-appearance: none;
            background: var(--terminal-cyan-dim);
            cursor: crosshair;
            position: relative;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--terminal-cyan);
            border: 2px solid var(--bg-black);
            cursor: crosshair;
            box-shadow: 0 0 10px var(--terminal-cyan-glow);
            transition: all 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--text-white);
            box-shadow: 0 0 20px var(--terminal-cyan-glow);
        }
        
        .slider-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 4px;
        }
        
        .slider-markers span {
            font-size: 8px;
            color: var(--text-dim);
            font-family: 'Space Mono', monospace;
        }
        
        /* ===== FREQUENCY BANDS ===== */
        .freq-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }
        
        .freq-btn {
            padding: 12px 4px;
            background: transparent;
            border: 1px solid var(--terminal-cyan-dim);
            color: var(--text-dim);
            cursor: crosshair;
            text-align: center;
            transition: all 0.2s;
            position: relative;
        }
        
        .freq-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: transparent;
            transition: background 0.2s;
        }
        
        .freq-btn:hover {
            border-color: var(--terminal-cyan);
            color: var(--terminal-cyan);
        }
        
        .freq-btn.active {
            border-color: var(--terminal-cyan);
            background: rgba(0, 255, 255, 0.05);
            color: var(--terminal-cyan);
        }
        
        .freq-btn.active::before {
            background: var(--terminal-cyan);
        }
        
        .freq-symbol {
            font-size: 16px;
            font-weight: 700;
            display: block;
            margin-bottom: 4px;
        }
        
        .freq-range {
            font-size: 7px;
            letter-spacing: 0.05em;
        }
        
        .freq-btn.delta .freq-symbol { color: #ff6666; }
        .freq-btn.theta .freq-symbol { color: #ffaa44; }
        .freq-btn.alpha .freq-symbol { color: #00ffff; }
        .freq-btn.beta .freq-symbol { color: #ff66ff; }
        .freq-btn.gamma .freq-symbol { color: #6666ff; }
        
        /* ===== NETWORK BUTTONS ===== */
        .network-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .network-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: transparent;
            border: 1px solid rgba(0, 255, 255, 0.15);
            color: var(--text-dim);
            cursor: crosshair;
            text-align: left;
            transition: all 0.2s;
        }
        
        .network-btn:hover {
            border-color: var(--terminal-cyan);
            color: var(--terminal-cyan);
        }
        
        .network-btn.active {
            border-color: var(--warning-red);
            border-left-width: 3px;
            background: rgba(255, 51, 68, 0.05);
        }
        
        .network-indicator {
            width: 8px;
            height: 8px;
        }
        
        .network-name {
            flex: 1;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .network-count {
            font-family: 'Space Mono', monospace;
            font-size: 10px;
            color: var(--terminal-cyan);
        }
        
        /* ===== ACTION BUTTONS ===== */
        .action-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 15px;
        }
        
        .action-btn {
            padding: 12px 15px;
            background: transparent;
            border: 1px solid var(--terminal-cyan);
            color: var(--terminal-cyan);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: crosshair;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .action-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .action-btn:hover::before {
            left: 100%;
        }
        
        .action-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: var(--border-glow);
        }
        
        .action-btn.primary {
            background: var(--terminal-cyan);
            color: var(--bg-black);
        }
        
        .action-btn.primary:hover {
            background: var(--text-white);
        }
        
        .action-btn.running {
            background: var(--warning-red);
            border-color: var(--warning-red);
            color: var(--bg-black);
        }
        
        /* ===== VISUALIZATION PANEL ===== */
        .viz-panel {
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .viz-container {
            flex: 1;
            position: relative;
            background: var(--bg-black);
            overflow: hidden;
        }
        
        #brain-canvas {
            width: 100%;
            height: 100%;
            min-height: 500px;
        }
        
        .viz-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            border: 1px solid var(--terminal-cyan-dim);
        }
        
        /* Corner brackets */
        .corner-bracket {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 1px solid var(--terminal-cyan);
        }
        
        .corner-bracket.tl { top: 15px; left: 15px; border-right: none; border-bottom: none; }
        .corner-bracket.tr { top: 15px; right: 15px; border-left: none; border-bottom: none; }
        .corner-bracket.bl { bottom: 15px; left: 15px; border-right: none; border-top: none; }
        .corner-bracket.br { bottom: 15px; right: 15px; border-left: none; border-top: none; }
        
        /* Targeting reticle */
        .reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            pointer-events: none;
        }
        
        .reticle::before,
        .reticle::after {
            content: '';
            position: absolute;
            background: var(--terminal-cyan);
            opacity: 0.3;
        }
        
        .reticle::before {
            width: 1px;
            height: 100%;
            left: 50%;
        }
        
        .reticle::after {
            width: 100%;
            height: 1px;
            top: 50%;
        }
        
        .reticle-ring {
            position: absolute;
            inset: 20px;
            border: 1px solid var(--terminal-cyan);
            border-radius: 50%;
            opacity: 0.2;
        }
        
        /* HUD overlays */
        .hud-label {
            position: absolute;
            font-size: 8px;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--terminal-cyan);
            opacity: 0.6;
        }
        
        .hud-label.top-left { top: 50px; left: 50px; }
        .hud-label.top-right { top: 50px; right: 50px; text-align: right; }
        .hud-label.bottom-left { bottom: 50px; left: 50px; }
        .hud-label.bottom-right { bottom: 50px; right: 50px; text-align: right; }
        
        .hud-value {
            font-size: 12px;
            font-weight: 700;
            color: var(--terminal-cyan);
            display: block;
            margin-top: 2px;
            font-family: 'Space Mono', monospace;
        }
        
        /* View controls */
        .viz-controls {
            display: flex;
            padding: 10px 15px;
            gap: 8px;
            border-top: 1px solid var(--terminal-cyan-dim);
            background: rgba(0, 255, 255, 0.02);
        }
        
        .view-btn {
            padding: 8px 14px;
            background: transparent;
            border: 1px solid var(--terminal-cyan-dim);
            color: var(--text-dim);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 9px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: crosshair;
            transition: all 0.2s;
        }
        
        .view-btn:hover {
            border-color: var(--terminal-cyan);
            color: var(--terminal-cyan);
        }
        
        .view-btn.active {
            background: var(--terminal-cyan);
            color: var(--bg-black);
        }
        
        /* ===== ANALYTICS PANEL ===== */
        .analytics-panel {
            overflow-y: auto;
            max-height: calc(100vh - 60px);
        }
        
        /* Order Parameter Display */
        .order-display {
            padding: 25px;
            text-align: center;
            border-bottom: 1px solid var(--terminal-cyan-dim);
            position: relative;
        }
        
        .order-display::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: linear-gradient(180deg, rgba(0, 255, 255, 0.03) 0%, transparent 100%);
            pointer-events: none;
        }
        
        .order-label {
            font-size: 8px;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--text-dim);
            margin-bottom: 8px;
        }
        
        .order-value {
            font-family: 'Space Mono', monospace;
            font-size: 56px;
            font-weight: 400;
            color: var(--terminal-cyan);
            text-shadow: 0 0 30px var(--terminal-cyan-glow);
            line-height: 1;
            letter-spacing: -0.02em;
        }
        
        .order-bar {
            margin-top: 15px;
            height: 4px;
            background: var(--terminal-cyan-dim);
            position: relative;
        }
        
        .order-bar-fill {
            height: 100%;
            background: var(--terminal-cyan);
            box-shadow: 0 0 10px var(--terminal-cyan-glow);
            transition: width 0.1s linear;
        }
        
        .order-bar-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
        }
        
        .order-bar-markers span {
            font-size: 8px;
            color: var(--text-dim);
            font-family: 'Space Mono', monospace;
        }
        
        .sync-status {
            margin-top: 12px;
            padding: 6px 15px;
            font-size: 9px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            display: inline-block;
        }
        
        .sync-status.coherent {
            border: 1px solid var(--success-green);
            color: var(--success-green);
            background: rgba(0, 255, 102, 0.05);
        }
        
        .sync-status.partial {
            border: 1px solid var(--alert-yellow);
            color: var(--alert-yellow);
            background: rgba(255, 204, 0, 0.05);
        }
        
        .sync-status.incoherent {
            border: 1px solid var(--warning-red);
            color: var(--warning-red);
            background: rgba(255, 51, 68, 0.05);
        }
        
        /* Data readouts */
        .data-section {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            padding: 8px 0;
            border-bottom: 1px dotted rgba(0, 255, 255, 0.1);
        }
        
        .data-row:last-child {
            border-bottom: none;
        }
        
        .data-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-dim);
        }
        
        .data-value {
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            font-weight: 700;
            color: var(--terminal-cyan);
        }
        
        /* Phase ring */
        .phase-section {
            padding: 20px;
            text-align: center;
        }
        
        .phase-ring-container {
            width: 160px;
            height: 160px;
            margin: 0 auto;
            position: relative;
        }
        
        #phase-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Chart */
        .chart-section {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .chart-title {
            font-size: 9px;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--text-dim);
        }
        
        .chart-wrapper {
            height: 80px;
            position: relative;
            background: rgba(0, 255, 255, 0.02);
            border: 1px solid rgba(0, 255, 255, 0.1);
        }
        
        /* Region list */
        .region-section {
            padding: 15px;
        }
        
        .region-header {
            display: flex;
            justify-content: space-between;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        .region-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .region-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 0;
            border-bottom: 1px dotted rgba(0, 255, 255, 0.05);
        }
        
        .region-dot {
            width: 6px;
            height: 6px;
        }
        
        .region-name {
            flex: 1;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-primary);
        }
        
        .region-freq {
            font-family: 'Space Mono', monospace;
            font-size: 9px;
            color: var(--text-dim);
            width: 50px;
            text-align: right;
        }
        
        .region-bar {
            width: 40px;
            height: 3px;
            background: var(--terminal-cyan-dim);
            overflow: hidden;
        }
        
        .region-bar-fill {
            height: 100%;
            background: var(--terminal-cyan);
            transition: width 0.1s;
        }
        
        /* ===== SCROLLBAR ===== */
        ::-webkit-scrollbar {
            width: 4px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-black);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--terminal-cyan-dim);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--terminal-cyan);
        }
        
        /* ===== GLITCH EFFECT ===== */
        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }
        
        .glitch-text {
            position: relative;
        }
        
        .glitch-text::before,
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .glitch-text::before {
            color: var(--warning-red);
            animation: glitch 0.3s infinite;
            clip-path: polygon(0 0, 100% 0, 100% 35%, 0 35%);
            transform: translate(-2px);
            opacity: 0.8;
        }
        
        .glitch-text::after {
            color: var(--terminal-cyan);
            animation: glitch 0.3s infinite reverse;
            clip-path: polygon(0 65%, 100% 65%, 100% 100%, 0 100%);
            transform: translate(2px);
            opacity: 0.8;
        }
        
        /* ===== LOADING ===== */
        .loading-screen {
            position: fixed;
            inset: 0;
            background: var(--bg-black);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s, visibility 0.5s;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .loading-ascii {
            font-family: 'Space Mono', monospace;
            font-size: 10px;
            color: var(--terminal-cyan);
            white-space: pre;
            line-height: 1.2;
            text-shadow: 0 0 10px var(--terminal-cyan-glow);
            animation: flicker 0.1s infinite;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; }
        }
        
        .loading-bar {
            width: 300px;
            height: 2px;
            background: var(--terminal-cyan-dim);
            margin-top: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .loading-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--terminal-cyan);
            animation: loading 1.5s ease-in-out infinite;
        }
        
        @keyframes loading {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .loading-text {
            margin-top: 20px;
            font-size: 9px;
            letter-spacing: 0.3em;
            color: var(--text-dim);
            text-transform: uppercase;
        }
        
        /* ===== RESPONSIVE ===== */
        @media (max-width: 1400px) {
            .main-container {
                grid-template-columns: 260px 1fr 300px;
            }
        }
        
        @media (max-width: 1100px) {
            .main-container {
                grid-template-columns: 1fr;
            }
            
            .controls-panel, .analytics-panel {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loading">
        <pre class="loading-ascii">
    ╔══════════════════════════════════════╗
    ║                                      ║
    ║     ███╗   ██╗███████╗██╗   ██╗      ║
    ║     ████╗  ██║██╔════╝██║   ██║      ║
    ║     ██╔██╗ ██║█████╗  ██║   ██║      ║
    ║     ██║╚██╗██║██╔══╝  ██║   ██║      ║
    ║     ██║ ╚████║███████╗╚██████╔╝      ║
    ║     ╚═╝  ╚═══╝╚══════╝ ╚═════╝       ║
    ║                                      ║
    ║     KURAMOTO CORTICAL MONITOR        ║
    ║     v2.7.1 // BUILD 2025.001         ║
    ║                                      ║
    ╚══════════════════════════════════════╝
        </pre>
        <div class="loading-bar"></div>
        <div class="loading-text">Initializing Neural Topology...</div>
    </div>

    <!-- CRT Effects -->
    <div class="crt-overlay"></div>
    
    <!-- Background Grid -->
    <div class="plus-grid"></div>

    <!-- Header -->
    <header>
        <div class="logo-section">
            <div class="logo-mark">
                <span></span>
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div>
                <div class="system-title">
                    NEURAL<span class="highlight">::</span>SYNC
                </div>
                <div class="system-subtitle">
                    Kuramoto Cortical Monitor // v2.7.1
                </div>
            </div>
        </div>
        <div class="header-stats">
            <div class="stat-block">
                <div class="stat-label">Nodes Active</div>
                <div class="stat-value" id="node-count">66</div>
            </div>
            <div class="stat-block">
                <div class="stat-label">Frequency</div>
                <div class="stat-value" id="header-freq">10.0 Hz</div>
            </div>
            <div class="stat-block">
                <div class="stat-label">Coupling</div>
                <div class="stat-value" id="header-coupling">0.035</div>
            </div>
            <div class="status-indicator">
                <div class="status-dot"></div>
                <span class="status-text">System Online</span>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <main class="main-container">
        <!-- Controls Panel -->
        <aside class="panel controls-panel">
            <div class="panel-header">
                <span class="panel-title">Parameters</span>
                <span class="panel-id">SYS.001</span>
            </div>
            
            <!-- Kuramoto Parameters -->
            <div class="control-section">
                <div class="section-header">
                    <div class="section-marker"></div>
                    <span class="section-title">Kuramoto Model</span>
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Coupling Strength (K)</span>
                        <span class="slider-value" id="k-value">0.035</span>
                    </div>
                    <div class="slider-track">
                        <input type="range" id="k-slider" min="0" max="0.1" step="0.001" value="0.035">
                    </div>
                    <div class="slider-markers">
                        <span>0.000</span>
                        <span>K_c</span>
                        <span>0.100</span>
                    </div>
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Frequency Spread (σ)</span>
                        <span class="slider-value" id="sigma-value">1.5 Hz</span>
                    </div>
                    <div class="slider-track">
                        <input type="range" id="sigma-slider" min="0.1" max="5" step="0.1" value="1.5">
                    </div>
                    <div class="slider-markers">
                        <span>0.1</span>
                        <span>5.0</span>
                    </div>
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Noise Level</span>
                        <span class="slider-value" id="noise-value">0.10</span>
                    </div>
                    <div class="slider-track">
                        <input type="range" id="noise-slider" min="0" max="1" step="0.01" value="0.1">
                    </div>
                    <div class="slider-markers">
                        <span>0.0</span>
                        <span>1.0</span>
                    </div>
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Time Step (dt)</span>
                        <span class="slider-value" id="dt-value">0.010s</span>
                    </div>
                    <div class="slider-track">
                        <input type="range" id="dt-slider" min="0.001" max="0.05" step="0.001" value="0.01">
                    </div>
                    <div class="slider-markers">
                        <span>0.001</span>
                        <span>0.050</span>
                    </div>
                </div>
            </div>
            
            <!-- Frequency Bands -->
            <div class="control-section">
                <div class="section-header">
                    <div class="section-marker"></div>
                    <span class="section-title">EEG Frequency Band</span>
                </div>
                
                <div class="freq-grid">
                    <button class="freq-btn delta" data-freq="2" data-sigma="1">
                        <span class="freq-symbol">δ</span>
                        <span class="freq-range">0.5-4Hz</span>
                    </button>
                    <button class="freq-btn theta" data-freq="6" data-sigma="1.5">
                        <span class="freq-symbol">θ</span>
                        <span class="freq-range">4-8Hz</span>
                    </button>
                    <button class="freq-btn alpha active" data-freq="10" data-sigma="1.5">
                        <span class="freq-symbol">α</span>
                        <span class="freq-range">8-13Hz</span>
                    </button>
                    <button class="freq-btn beta" data-freq="20" data-sigma="4">
                        <span class="freq-symbol">β</span>
                        <span class="freq-range">13-30Hz</span>
                    </button>
                    <button class="freq-btn gamma" data-freq="45" data-sigma="10">
                        <span class="freq-symbol">γ</span>
                        <span class="freq-range">30-80Hz</span>
                    </button>
                </div>
            </div>
            
            <!-- Network Selection -->
            <div class="control-section">
                <div class="section-header">
                    <div class="section-marker"></div>
                    <span class="section-title">Functional Networks</span>
                </div>
                
                <div class="network-list">
                    <button class="network-btn active" data-network="all">
                        <div class="network-indicator" style="background: linear-gradient(135deg, #00ffff, #ff3344)"></div>
                        <span class="network-name">All Networks</span>
                        <span class="network-count">66</span>
                    </button>
                    <button class="network-btn" data-network="dmn">
                        <div class="network-indicator" style="background: #ff6666"></div>
                        <span class="network-name">Default Mode</span>
                        <span class="network-count">11</span>
                    </button>
                    <button class="network-btn" data-network="visual">
                        <div class="network-indicator" style="background: #00ccff"></div>
                        <span class="network-name">Visual</span>
                        <span class="network-count">10</span>
                    </button>
                    <button class="network-btn" data-network="motor">
                        <div class="network-indicator" style="background: #ff66ff"></div>
                        <span class="network-name">Sensorimotor</span>
                        <span class="network-count">12</span>
                    </button>
                    <button class="network-btn" data-network="attention">
                        <div class="network-indicator" style="background: #ffaa44"></div>
                        <span class="network-name">Attention</span>
                        <span class="network-count">8</span>
                    </button>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="control-section">
                <div class="action-group">
                    <button class="action-btn primary" id="btn-start">▶ Execute</button>
                    <button class="action-btn" id="btn-reset">↺ Reset</button>
                </div>
            </div>
        </aside>

        <!-- Visualization Panel -->
        <section class="panel viz-panel">
            <div class="panel-header">
                <span class="panel-title">3D Connectome</span>
                <span class="panel-id"><span id="fps-display">60</span> FPS</span>
            </div>
            
            <div class="viz-container">
                <canvas id="brain-canvas"></canvas>
                
                <!-- Overlay elements -->
                <div class="viz-overlay">
                    <div class="corner-bracket tl"></div>
                    <div class="corner-bracket tr"></div>
                    <div class="corner-bracket bl"></div>
                    <div class="corner-bracket br"></div>
                    
                    <div class="reticle">
                        <div class="reticle-ring"></div>
                    </div>
                    
                    <div class="hud-label top-left">
                        Est. Relative<br>
                        <span class="hud-value" id="hud-network">ALL NETWORKS</span>
                    </div>
                    
                    <div class="hud-label top-right">
                        System<br>
                        <span class="hud-value" id="hud-system">α: 76.75</span>
                    </div>
                    
                    <div class="hud-label bottom-left">
                        Time<br>
                        <span class="hud-value" id="hud-time">0.00s</span>
                    </div>
                    
                    <div class="hud-label bottom-right">
                        Order<br>
                        <span class="hud-value" id="hud-order">r: 0.00</span>
                    </div>
                </div>
            </div>
            
            <div class="viz-controls">
                <button class="view-btn active" id="view-3d">3D</button>
                <button class="view-btn" id="view-top">Top</button>
                <button class="view-btn" id="view-side">Side</button>
                <button class="view-btn" id="view-front">Front</button>
                <button class="view-btn" id="toggle-conn">Conn</button>
                <button class="view-btn" id="toggle-glitch">Glitch</button>
            </div>
        </section>

        <!-- Analytics Panel -->
        <aside class="panel analytics-panel">
            <div class="panel-header">
                <span class="panel-title">Analytics</span>
                <span class="panel-id">SYS.002</span>
            </div>
            
            <!-- Order Parameter -->
            <div class="order-display">
                <div class="order-label">Order Parameter (r)</div>
                <div class="order-value glitch-text" data-text="0.00" id="order-value">0.00</div>
                <div class="order-bar">
                    <div class="order-bar-fill" id="order-bar" style="width: 0%"></div>
                </div>
                <div class="order-bar-markers">
                    <span>0.0</span>
                    <span>0.5</span>
                    <span>1.0</span>
                </div>
                <div class="sync-status incoherent" id="sync-status">Incoherent</div>
            </div>
            
            <!-- Data Readouts -->
            <div class="data-section">
                <div class="section-header">
                    <div class="section-marker"></div>
                    <span class="section-title">System Metrics</span>
                </div>
                
                <div class="data-row">
                    <span class="data-label">Mean Frequency</span>
                    <span class="data-value" id="mean-freq">10.00 Hz</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Coherence</span>
                    <span class="data-value" id="coherence">0.00</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Sync Clusters</span>
                    <span class="data-value" id="clusters">1</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Simulation Time</span>
                    <span class="data-value" id="sim-time">0.00s</span>
                </div>
            </div>
            
            <!-- Phase Ring -->
            <div class="phase-section">
                <div class="section-header" style="justify-content: center;">
                    <span class="section-title">Phase Distribution</span>
                </div>
                <div class="phase-ring-container">
                    <canvas id="phase-canvas"></canvas>
                </div>
            </div>
            
            <!-- History Chart -->
            <div class="chart-section">
                <div class="chart-header">
                    <span class="chart-title">Order History</span>
                </div>
                <div class="chart-wrapper">
                    <canvas id="history-canvas"></canvas>
                </div>
            </div>
            
            <!-- Region List -->
            <div class="region-section">
                <div class="region-header">
                    <span class="section-title">Active Regions</span>
                    <span class="panel-id" id="region-count">15/66</span>
                </div>
                <div class="region-list" id="region-list">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </aside>
    </main>

    <script>
    // ════════════════════════════════════════════════════════════════
    // NEURAL::SYNC - KURAMOTO CORTICAL MONITOR v2.7.1
    // Based on Human Connectome Project empirical data
    // ════════════════════════════════════════════════════════════════

    // Brain regions from HCP parcellation with MNI coordinates
    const BRAIN_REGIONS = [
        // Default Mode Network (DMN)
        { name: "PCC", x: 0, y: -53, z: 26, network: "dmn", fullName: "Posterior Cingulate" },
        { name: "mPFC", x: 0, y: 52, z: -6, network: "dmn", fullName: "Medial Prefrontal" },
        { name: "L-LPC", x: -48, y: -62, z: 36, network: "dmn", fullName: "Left Lateral Parietal" },
        { name: "R-LPC", x: 48, y: -67, z: 36, network: "dmn", fullName: "Right Lateral Parietal" },
        { name: "L-PHG", x: -24, y: -33, z: -18, network: "dmn", fullName: "Left Parahippocampal" },
        { name: "R-PHG", x: 24, y: -33, z: -18, network: "dmn", fullName: "Right Parahippocampal" },
        { name: "L-TPJ", x: -54, y: -54, z: 28, network: "dmn", fullName: "Left Temporoparietal" },
        { name: "R-TPJ", x: 54, y: -54, z: 28, network: "dmn", fullName: "Right Temporoparietal" },
        { name: "dmPFC", x: -3, y: 55, z: 22, network: "dmn", fullName: "Dorsal Medial PFC" },
        { name: "vmPFC", x: -3, y: 59, z: -7, network: "dmn", fullName: "Ventral Medial PFC" },
        { name: "Precuneus", x: 0, y: -60, z: 40, network: "dmn", fullName: "Precuneus" },
        
        // Visual Network
        { name: "L-V1", x: -8, y: -88, z: 0, network: "visual", fullName: "Left Primary Visual" },
        { name: "R-V1", x: 8, y: -88, z: 0, network: "visual", fullName: "Right Primary Visual" },
        { name: "L-V2", x: -18, y: -95, z: 8, network: "visual", fullName: "Left V2" },
        { name: "R-V2", x: 18, y: -95, z: 8, network: "visual", fullName: "Right V2" },
        { name: "L-V3", x: -25, y: -90, z: 12, network: "visual", fullName: "Left V3" },
        { name: "R-V3", x: 25, y: -90, z: 12, network: "visual", fullName: "Right V3" },
        { name: "L-V4", x: -30, y: -80, z: -10, network: "visual", fullName: "Left V4" },
        { name: "R-V4", x: 30, y: -80, z: -10, network: "visual", fullName: "Right V4" },
        { name: "L-MT", x: -45, y: -75, z: 5, network: "visual", fullName: "Left MT/V5" },
        { name: "R-MT", x: 45, y: -75, z: 5, network: "visual", fullName: "Right MT/V5" },
        
        // Sensorimotor Network
        { name: "L-M1", x: -38, y: -20, z: 55, network: "motor", fullName: "Left Primary Motor" },
        { name: "R-M1", x: 38, y: -20, z: 55, network: "motor", fullName: "Right Primary Motor" },
        { name: "L-S1", x: -42, y: -28, z: 52, network: "motor", fullName: "Left Somatosensory" },
        { name: "R-S1", x: 42, y: -28, z: 52, network: "motor", fullName: "Right Somatosensory" },
        { name: "L-PMC", x: -30, y: -8, z: 58, network: "motor", fullName: "Left Premotor" },
        { name: "R-PMC", x: 30, y: -8, z: 58, network: "motor", fullName: "Right Premotor" },
        { name: "SMA", x: 0, y: -5, z: 62, network: "motor", fullName: "Supplementary Motor" },
        { name: "L-SPL", x: -28, y: -48, z: 58, network: "motor", fullName: "Left Superior Parietal" },
        { name: "R-SPL", x: 28, y: -48, z: 58, network: "motor", fullName: "Right Superior Parietal" },
        { name: "L-Cereb", x: -25, y: -55, z: -30, network: "motor", fullName: "Left Cerebellum" },
        { name: "R-Cereb", x: 25, y: -55, z: -30, network: "motor", fullName: "Right Cerebellum" },
        { name: "Vermis", x: 0, y: -60, z: -25, network: "motor", fullName: "Cerebellar Vermis" },
        
        // Attention/Salience Network
        { name: "L-FEF", x: -30, y: -2, z: 52, network: "attention", fullName: "Left Frontal Eye Field" },
        { name: "R-FEF", x: 30, y: -2, z: 52, network: "attention", fullName: "Right Frontal Eye Field" },
        { name: "L-IPS", x: -28, y: -58, z: 48, network: "attention", fullName: "Left Intraparietal" },
        { name: "R-IPS", x: 28, y: -58, z: 48, network: "attention", fullName: "Right Intraparietal" },
        { name: "L-AI", x: -35, y: 18, z: 5, network: "attention", fullName: "Left Anterior Insula" },
        { name: "R-AI", x: 35, y: 18, z: 5, network: "attention", fullName: "Right Anterior Insula" },
        { name: "dACC", x: 0, y: 20, z: 40, network: "attention", fullName: "Dorsal ACC" },
        { name: "preSMA", x: 0, y: 10, z: 55, network: "attention", fullName: "Pre-SMA" },
        
        // Frontal
        { name: "L-DLPFC", x: -42, y: 35, z: 28, network: "frontal", fullName: "Left DLPFC" },
        { name: "R-DLPFC", x: 42, y: 35, z: 28, network: "frontal", fullName: "Right DLPFC" },
        { name: "L-VLPFC", x: -45, y: 28, z: 8, network: "frontal", fullName: "Left VLPFC" },
        { name: "R-VLPFC", x: 45, y: 28, z: 8, network: "frontal", fullName: "Right VLPFC" },
        { name: "L-OFC", x: -25, y: 40, z: -15, network: "frontal", fullName: "Left Orbitofrontal" },
        { name: "R-OFC", x: 25, y: 40, z: -15, network: "frontal", fullName: "Right Orbitofrontal" },
        { name: "L-IFG", x: -50, y: 20, z: 10, network: "frontal", fullName: "Left Inferior Frontal" },
        { name: "R-IFG", x: 50, y: 20, z: 10, network: "frontal", fullName: "Right Inferior Frontal" },
        
        // Temporal
        { name: "L-STG", x: -55, y: -15, z: 5, network: "temporal", fullName: "Left Superior Temporal" },
        { name: "R-STG", x: 55, y: -15, z: 5, network: "temporal", fullName: "Right Superior Temporal" },
        { name: "L-MTG", x: -58, y: -30, z: -5, network: "temporal", fullName: "Left Middle Temporal" },
        { name: "R-MTG", x: 58, y: -30, z: -5, network: "temporal", fullName: "Right Middle Temporal" },
        { name: "L-ITG", x: -55, y: -45, z: -15, network: "temporal", fullName: "Left Inferior Temporal" },
        { name: "R-ITG", x: 55, y: -45, z: -15, network: "temporal", fullName: "Right Inferior Temporal" },
        { name: "L-Hipp", x: -25, y: -20, z: -12, network: "temporal", fullName: "Left Hippocampus" },
        { name: "R-Hipp", x: 25, y: -20, z: -12, network: "temporal", fullName: "Right Hippocampus" },
        
        // Subcortical
        { name: "L-Thal", x: -10, y: -18, z: 8, network: "subcortical", fullName: "Left Thalamus" },
        { name: "R-Thal", x: 10, y: -18, z: 8, network: "subcortical", fullName: "Right Thalamus" },
        { name: "L-Caud", x: -12, y: 10, z: 10, network: "subcortical", fullName: "Left Caudate" },
        { name: "R-Caud", x: 12, y: 10, z: 10, network: "subcortical", fullName: "Right Caudate" },
        { name: "L-Put", x: -25, y: 5, z: 0, network: "subcortical", fullName: "Left Putamen" },
        { name: "R-Put", x: 25, y: 5, z: 0, network: "subcortical", fullName: "Right Putamen" },
        { name: "L-Amyg", x: -22, y: -5, z: -18, network: "subcortical", fullName: "Left Amygdala" },
        { name: "R-Amyg", x: 22, y: -5, z: -18, network: "subcortical", fullName: "Right Amygdala" },
        { name: "Brainstem", x: 0, y: -30, z: -35, network: "subcortical", fullName: "Brainstem" }
    ];

    const NETWORK_COLORS = {
        dmn: 0xff6666,
        visual: 0x00ccff,
        motor: 0xff66ff,
        attention: 0xffaa44,
        frontal: 0x6699ff,
        temporal: 0xcc66ff,
        subcortical: 0x00ffcc
    };

    // ════════════════════════════════════════════════════════════════
    // KURAMOTO MODEL
    // ════════════════════════════════════════════════════════════════
    class KuramotoModel {
        constructor(regions) {
            this.regions = regions;
            this.N = regions.length;
            this.phases = new Float64Array(this.N);
            this.naturalFrequencies = new Float64Array(this.N);
            this.couplingMatrix = this.buildCouplingMatrix();
            
            this.K = 0.035;
            this.meanFreq = 10;
            this.sigma = 1.5;
            this.dt = 0.01;
            this.noiseLevel = 0.1;
            this.time = 0;
            this.orderHistory = [];
            this.maxHistory = 150;
            
            this.reset();
        }
        
        buildCouplingMatrix() {
            const matrix = [];
            for (let i = 0; i < this.N; i++) {
                matrix[i] = [];
                for (let j = 0; j < this.N; j++) {
                    if (i === j) {
                        matrix[i][j] = 0;
                    } else {
                        const ri = this.regions[i];
                        const rj = this.regions[j];
                        const dist = Math.sqrt(
                            Math.pow(ri.x - rj.x, 2) +
                            Math.pow(ri.y - rj.y, 2) +
                            Math.pow(ri.z - rj.z, 2)
                        );
                        const networkBoost = ri.network === rj.network ? 2.0 : 1.0;
                        matrix[i][j] = networkBoost / (1 + dist / 30);
                    }
                }
                const sum = matrix[i].reduce((a, b) => a + b, 0);
                if (sum > 0) {
                    for (let j = 0; j < this.N; j++) {
                        matrix[i][j] /= sum;
                    }
                }
            }
            return matrix;
        }
        
        reset() {
            for (let i = 0; i < this.N; i++) {
                this.phases[i] = Math.random() * 2 * Math.PI;
            }
            this.initializeFrequencies();
            this.time = 0;
            this.orderHistory = [];
        }
        
        initializeFrequencies() {
            for (let i = 0; i < this.N; i++) {
                const u1 = Math.random();
                const u2 = Math.random();
                const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                this.naturalFrequencies[i] = this.meanFreq + this.sigma * z;
            }
        }
        
        setParameters(params) {
            if (params.K !== undefined) this.K = params.K;
            if (params.meanFreq !== undefined) {
                this.meanFreq = params.meanFreq;
                this.initializeFrequencies();
            }
            if (params.sigma !== undefined) {
                this.sigma = params.sigma;
                this.initializeFrequencies();
            }
            if (params.dt !== undefined) this.dt = params.dt;
            if (params.noiseLevel !== undefined) this.noiseLevel = params.noiseLevel;
        }
        
        step() {
            const newPhases = new Float64Array(this.N);
            
            for (let i = 0; i < this.N; i++) {
                let coupling = 0;
                for (let j = 0; j < this.N; j++) {
                    coupling += this.couplingMatrix[i][j] * Math.sin(this.phases[j] - this.phases[i]);
                }
                
                const noise = this.noiseLevel * (Math.random() - 0.5) * 2;
                const omega = 2 * Math.PI * this.naturalFrequencies[i];
                const dTheta = omega + this.K * this.N * coupling + noise;
                newPhases[i] = this.phases[i] + dTheta * this.dt;
                newPhases[i] = ((newPhases[i] % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            }
            
            this.phases = newPhases;
            this.time += this.dt;
            
            const r = this.calculateOrderParameter();
            this.orderHistory.push(r);
            if (this.orderHistory.length > this.maxHistory) {
                this.orderHistory.shift();
            }
            
            return r;
        }
        
        calculateOrderParameter() {
            let realPart = 0;
            let imagPart = 0;
            
            for (let i = 0; i < this.N; i++) {
                realPart += Math.cos(this.phases[i]);
                imagPart += Math.sin(this.phases[i]);
            }
            
            realPart /= this.N;
            imagPart /= this.N;
            
            return Math.sqrt(realPart * realPart + imagPart * imagPart);
        }
        
        getMeanPhase() {
            let realPart = 0;
            let imagPart = 0;
            
            for (let i = 0; i < this.N; i++) {
                realPart += Math.cos(this.phases[i]);
                imagPart += Math.sin(this.phases[i]);
            }
            
            return Math.atan2(imagPart, realPart);
        }
        
        countSyncClusters(threshold = 0.5) {
            const clusters = [];
            const assigned = new Array(this.N).fill(false);
            
            for (let i = 0; i < this.N; i++) {
                if (assigned[i]) continue;
                
                const cluster = [i];
                assigned[i] = true;
                
                for (let j = i + 1; j < this.N; j++) {
                    if (assigned[j]) continue;
                    
                    const phaseDiff = Math.abs(this.phases[i] - this.phases[j]);
                    const minDiff = Math.min(phaseDiff, 2 * Math.PI - phaseDiff);
                    
                    if (minDiff < threshold) {
                        cluster.push(j);
                        assigned[j] = true;
                    }
                }
                
                if (cluster.length > 1) {
                    clusters.push(cluster);
                }
            }
            
            return Math.max(1, clusters.length);
        }
    }

    // ════════════════════════════════════════════════════════════════
    // 3D VISUALIZATION
    // ════════════════════════════════════════════════════════════════
    class BrainVisualization {
        constructor(canvas, model) {
            this.canvas = canvas;
            this.model = model;
            this.showConnections = true;
            this.glitchEnabled = false;
            this.activeNetwork = 'all';
            
            this.init();
        }
        
        init() {
            this.scene = new THREE.Scene();
            
            const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
            this.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            this.camera.position.set(0, 0, 220);
            
            this.renderer = new THREE.WebGLRenderer({
                canvas: this.canvas,
                antialias: true,
                alpha: true
            });
            this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            this.renderer.setClearColor(0x000000, 1);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x00ffff, 0.2);
            this.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x00ffff, 0.5);
            directionalLight.position.set(100, 100, 100);
            this.scene.add(directionalLight);
            
            const backLight = new THREE.DirectionalLight(0xff3344, 0.3);
            backLight.position.set(-100, -50, -100);
            this.scene.add(backLight);
            
            this.createBrainOutline();
            this.createRegionNodes();
            this.createConnections();
            this.setupControls();
            
            window.addEventListener('resize', () => this.onResize());
        }
        
        createBrainOutline() {
            // Wireframe brain shape
            const geometry = new THREE.IcosahedronGeometry(75, 2);
            geometry.scale(1, 0.85, 0.95);
            
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.03,
                wireframe: true
            });
            
            this.brainWireframe = new THREE.Mesh(geometry, wireframeMaterial);
            this.scene.add(this.brainWireframe);
            
            // Outer glow sphere
            const glowGeometry = new THREE.SphereGeometry(80, 32, 32);
            glowGeometry.scale(1, 0.85, 0.95);
            
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.02,
                side: THREE.BackSide
            });
            
            this.brainGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            this.scene.add(this.brainGlow);
        }
        
        createRegionNodes() {
            this.nodes = [];
            this.nodeGroup = new THREE.Group();
            
            const scale = 0.75;
            
            for (let i = 0; i < this.model.regions.length; i++) {
                const region = this.model.regions[i];
                
                // Main node
                const geometry = new THREE.OctahedronGeometry(2.5, 0);
                const color = NETWORK_COLORS[region.network] || 0x00ffff;
                
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9,
                    wireframe: false
                });
                
                const node = new THREE.Mesh(geometry, material);
                node.position.set(
                    region.x * scale,
                    region.z * scale,
                    -region.y * scale
                );
                node.userData = { index: i, region: region, baseColor: color };
                
                // Node ring
                const ringGeometry = new THREE.RingGeometry(4, 4.5, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(node.position);
                
                this.nodes.push({ node, ring });
                this.nodeGroup.add(node);
                this.nodeGroup.add(ring);
            }
            
            this.scene.add(this.nodeGroup);
        }
        
        createConnections() {
            this.connectionGroup = new THREE.Group();
            this.connections = [];
            
            for (let i = 0; i < this.model.N; i++) {
                for (let j = i + 1; j < this.model.N; j++) {
                    const coupling = this.model.couplingMatrix[i][j];
                    if (coupling > 0.04) {
                        const geometry = new THREE.BufferGeometry();
                        const positions = new Float32Array(6);
                        
                        const p1 = this.nodes[i].node.position;
                        const p2 = this.nodes[j].node.position;
                        
                        positions[0] = p1.x; positions[1] = p1.y; positions[2] = p1.z;
                        positions[3] = p2.x; positions[4] = p2.y; positions[5] = p2.z;
                        
                        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const material = new THREE.LineBasicMaterial({
                            color: 0x00ffff,
                            transparent: true,
                            opacity: coupling * 0.3
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.userData = { i, j, baseCoupling: coupling };
                        
                        this.connections.push(line);
                        this.connectionGroup.add(line);
                    }
                }
            }
            
            this.scene.add(this.connectionGroup);
        }
        
        setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            this.canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            this.canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                this.nodeGroup.rotation.y += deltaX * 0.005;
                this.nodeGroup.rotation.x += deltaY * 0.005;
                this.connectionGroup.rotation.y += deltaX * 0.005;
                this.connectionGroup.rotation.x += deltaY * 0.005;
                this.brainWireframe.rotation.y += deltaX * 0.005;
                this.brainWireframe.rotation.x += deltaY * 0.005;
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            this.canvas.addEventListener('mouseup', () => isDragging = false);
            this.canvas.addEventListener('mouseleave', () => isDragging = false);
            
            this.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                this.camera.position.z += e.deltaY * 0.1;
                this.camera.position.z = Math.max(120, Math.min(400, this.camera.position.z));
            });
        }
        
        setView(view) {
            const duration = 500;
            const targetRotation = { x: 0, y: 0 };
            
            switch(view) {
                case 'top': targetRotation.x = -Math.PI / 2; break;
                case 'side': targetRotation.y = Math.PI / 2; break;
                case 'front': targetRotation.x = 0; targetRotation.y = 0; break;
            }
            
            const startRotation = {
                x: this.nodeGroup.rotation.x,
                y: this.nodeGroup.rotation.y
            };
            const startTime = performance.now();
            
            const animate = () => {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                this.nodeGroup.rotation.x = startRotation.x + (targetRotation.x - startRotation.x) * eased;
                this.nodeGroup.rotation.y = startRotation.y + (targetRotation.y - startRotation.y) * eased;
                this.connectionGroup.rotation.x = this.nodeGroup.rotation.x;
                this.connectionGroup.rotation.y = this.nodeGroup.rotation.y;
                this.brainWireframe.rotation.x = this.nodeGroup.rotation.x;
                this.brainWireframe.rotation.y = this.nodeGroup.rotation.y;
                
                if (progress < 1) requestAnimationFrame(animate);
            };
            
            animate();
        }
        
        setNetwork(network) {
            this.activeNetwork = network;
            
            for (let i = 0; i < this.nodes.length; i++) {
                const { node, ring } = this.nodes[i];
                const region = node.userData.region;
                
                if (network === 'all' || region.network === network) {
                    node.material.opacity = 0.9;
                    node.scale.setScalar(1);
                    ring.material.opacity = 0.3;
                } else {
                    node.material.opacity = 0.15;
                    node.scale.setScalar(0.5);
                    ring.material.opacity = 0.05;
                }
            }
            
            for (const conn of this.connections) {
                const ri = this.model.regions[conn.userData.i];
                const rj = this.model.regions[conn.userData.j];
                
                if (network === 'all' || (ri.network === network && rj.network === network)) {
                    conn.material.opacity = conn.userData.baseCoupling * 0.3;
                } else {
                    conn.material.opacity = 0.02;
                }
            }
        }
        
        update() {
            const time = performance.now() * 0.001;
            
            // Update nodes based on phase
            for (let i = 0; i < this.nodes.length; i++) {
                const { node, ring } = this.nodes[i];
                const phase = this.model.phases[i];
                const intensity = (Math.sin(phase) + 1) / 2;
                
                // Pulse effect
                const pulseScale = 1 + intensity * 0.4;
                const isActive = this.activeNetwork === 'all' || node.userData.region.network === this.activeNetwork;
                node.scale.setScalar(pulseScale * (isActive ? 1 : 0.5));
                
                // Rotate ring
                ring.rotation.x = time + i * 0.1;
                ring.rotation.y = time * 0.5;
                
                // Color intensity
                if (intensity > 0.7) {
                    node.material.color.setHex(0xffffff);
                } else {
                    node.material.color.setHex(node.userData.baseColor);
                }
            }
            
            // Update connections based on sync
            if (this.showConnections) {
                for (const conn of this.connections) {
                    const phaseDiff = Math.abs(this.model.phases[conn.userData.i] - this.model.phases[conn.userData.j]);
                    const sync = Math.cos(phaseDiff);
                    
                    if (sync > 0.5) {
                        conn.material.color.setHex(0x00ffff);
                        conn.material.opacity = Math.min(sync * 0.5, 0.5);
                    } else {
                        conn.material.color.setHex(0x003333);
                        conn.material.opacity = 0.03;
                    }
                }
            }
            
            // Glitch effect
            if (this.glitchEnabled && Math.random() > 0.95) {
                this.nodeGroup.position.x = (Math.random() - 0.5) * 5;
                setTimeout(() => this.nodeGroup.position.x = 0, 50);
            }
            
            // Slow rotation
            this.brainWireframe.rotation.y += 0.001;
            this.brainGlow.rotation.y -= 0.0005;
            
            this.renderer.render(this.scene, this.camera);
        }
        
        toggleConnections(show) {
            this.showConnections = show;
            this.connectionGroup.visible = show;
        }
        
        toggleGlitch(enabled) {
            this.glitchEnabled = enabled;
        }
        
        onResize() {
            const width = this.canvas.clientWidth;
            const height = this.canvas.clientHeight;
            
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(width, height);
        }
    }

    // ════════════════════════════════════════════════════════════════
    // ANALYTICS & CHARTS
    // ════════════════════════════════════════════════════════════════
    class Analytics {
        constructor(model) {
            this.model = model;
            this.setupPhaseCanvas();
            this.setupHistoryCanvas();
        }
        
        setupPhaseCanvas() {
            this.phaseCanvas = document.getElementById('phase-canvas');
            this.phaseCtx = this.phaseCanvas.getContext('2d');
            
            const size = 160;
            this.phaseCanvas.width = size * 2;
            this.phaseCanvas.height = size * 2;
            this.phaseCanvas.style.width = size + 'px';
            this.phaseCanvas.style.height = size + 'px';
        }
        
        setupHistoryCanvas() {
            this.historyCanvas = document.getElementById('history-canvas');
            this.historyCtx = this.historyCanvas.getContext('2d');
            
            const rect = this.historyCanvas.parentElement.getBoundingClientRect();
            this.historyCanvas.width = rect.width * 2;
            this.historyCanvas.height = rect.height * 2;
            this.historyCanvas.style.width = '100%';
            this.historyCanvas.style.height = '100%';
        }
        
        update() {
            const r = this.model.calculateOrderParameter();
            
            // Update order parameter display
            const orderEl = document.getElementById('order-value');
            orderEl.textContent = r.toFixed(2);
            orderEl.dataset.text = r.toFixed(2);
            
            document.getElementById('order-bar').style.width = (r * 100) + '%';
            
            // Sync status
            const statusEl = document.getElementById('sync-status');
            if (r > 0.7) {
                statusEl.textContent = 'Coherent';
                statusEl.className = 'sync-status coherent';
            } else if (r > 0.3) {
                statusEl.textContent = 'Partial Sync';
                statusEl.className = 'sync-status partial';
            } else {
                statusEl.textContent = 'Incoherent';
                statusEl.className = 'sync-status incoherent';
            }
            
            // Metrics
            document.getElementById('mean-freq').textContent = this.model.meanFreq.toFixed(2) + ' Hz';
            document.getElementById('coherence').textContent = r.toFixed(3);
            document.getElementById('clusters').textContent = this.model.countSyncClusters();
            document.getElementById('sim-time').textContent = this.model.time.toFixed(2) + 's';
            
            // HUD
            document.getElementById('hud-time').textContent = this.model.time.toFixed(2) + 's';
            document.getElementById('hud-order').textContent = 'r: ' + r.toFixed(2);
            document.getElementById('hud-system').textContent = 'α: ' + (r * 100).toFixed(1);
            
            this.drawPhaseDistribution();
            this.drawHistoryChart();
        }
        
        drawPhaseDistribution() {
            const ctx = this.phaseCtx;
            const size = this.phaseCanvas.width;
            const center = size / 2;
            const radius = size / 2 - 30;
            
            ctx.clearRect(0, 0, size, size);
            
            // Grid lines
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(center, center);
                ctx.lineTo(center + radius * Math.cos(angle), center + radius * Math.sin(angle));
                ctx.stroke();
            }
            
            // Outer ring
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(center, center, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Inner rings
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(center, center, radius * 0.66, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(center, center, radius * 0.33, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Phase points
            for (let i = 0; i < this.model.N; i++) {
                const phase = this.model.phases[i];
                const x = center + radius * Math.cos(phase - Math.PI / 2);
                const y = center + radius * Math.sin(phase - Math.PI / 2);
                
                const region = this.model.regions[i];
                const color = NETWORK_COLORS[region.network] || 0x00ffff;
                const colorStr = '#' + color.toString(16).padStart(6, '0');
                
                ctx.fillStyle = colorStr;
                ctx.shadowColor = colorStr;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
            
            // Mean phase arrow
            const meanPhase = this.model.getMeanPhase();
            const r = this.model.calculateOrderParameter();
            const arrowLength = radius * r;
            
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(center, center);
            ctx.lineTo(
                center + arrowLength * Math.cos(meanPhase - Math.PI / 2),
                center + arrowLength * Math.sin(meanPhase - Math.PI / 2)
            );
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Arrow head
            const endX = center + arrowLength * Math.cos(meanPhase - Math.PI / 2);
            const endY = center + arrowLength * Math.sin(meanPhase - Math.PI / 2);
            const headAngle = 0.4;
            const headLength = 12;
            
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(meanPhase - Math.PI / 2 - headAngle),
                endY - headLength * Math.sin(meanPhase - Math.PI / 2 - headAngle)
            );
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(meanPhase - Math.PI / 2 + headAngle),
                endY - headLength * Math.sin(meanPhase - Math.PI / 2 + headAngle)
            );
            ctx.stroke();
        }
        
        drawHistoryChart() {
            const ctx = this.historyCtx;
            const width = this.historyCanvas.width;
            const height = this.historyCanvas.height;
            const history = this.model.orderHistory;
            
            ctx.clearRect(0, 0, width, height);
            
            if (history.length < 2) return;
            
            // Grid
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Line chart
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 5;
            
            ctx.beginPath();
            for (let i = 0; i < history.length; i++) {
                const x = (i / (this.model.maxHistory - 1)) * width;
                const y = height - history[i] * height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Fill
            ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();
        }
        
        updateRegionList() {
            const list = document.getElementById('region-list');
            list.innerHTML = '';
            
            const sortedIndices = [...Array(this.model.N).keys()].sort((a, b) => {
                return this.model.regions[a].network.localeCompare(this.model.regions[b].network);
            });
            
            for (let i = 0; i < Math.min(15, sortedIndices.length); i++) {
                const idx = sortedIndices[i];
                const region = this.model.regions[idx];
                const phase = this.model.phases[idx];
                const freq = this.model.naturalFrequencies[idx];
                const color = NETWORK_COLORS[region.network] || 0x00ffff;
                
                const item = document.createElement('div');
                item.className = 'region-item';
                item.innerHTML = `
                    <div class="region-dot" style="background: #${color.toString(16).padStart(6, '0')}"></div>
                    <span class="region-name">${region.name}</span>
                    <span class="region-freq">${freq.toFixed(1)}Hz</span>
                    <div class="region-bar">
                        <div class="region-bar-fill" style="width: ${((phase / (2 * Math.PI)) * 100).toFixed(0)}%"></div>
                    </div>
                `;
                list.appendChild(item);
            }
        }
    }

    // ════════════════════════════════════════════════════════════════
    // MAIN APPLICATION
    // ════════════════════════════════════════════════════════════════
    class App {
        constructor() {
            this.isRunning = false;
            this.frameCount = 0;
            this.lastFpsUpdate = performance.now();
            
            this.model = new KuramotoModel(BRAIN_REGIONS);
            
            const canvas = document.getElementById('brain-canvas');
            this.visualization = new BrainVisualization(canvas, this.model);
            
            this.analytics = new Analytics(this.model);
            
            this.setupControls();
            this.analytics.updateRegionList();
            
            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 2000);
            
            this.render();
        }
        
        setupControls() {
            // Sliders
            const kSlider = document.getElementById('k-slider');
            const sigmaSlider = document.getElementById('sigma-slider');
            const noiseSlider = document.getElementById('noise-slider');
            const dtSlider = document.getElementById('dt-slider');
            
            kSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('k-value').textContent = value.toFixed(3);
                document.getElementById('header-coupling').textContent = value.toFixed(3);
                this.model.setParameters({ K: value });
            });
            
            sigmaSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('sigma-value').textContent = value.toFixed(1) + ' Hz';
                this.model.setParameters({ sigma: value });
            });
            
            noiseSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('noise-value').textContent = value.toFixed(2);
                this.model.setParameters({ noiseLevel: value });
            });
            
            dtSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('dt-value').textContent = value.toFixed(3) + 's';
                this.model.setParameters({ dt: value });
            });
            
            // Frequency bands
            document.querySelectorAll('.freq-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.freq-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const freq = parseFloat(btn.dataset.freq);
                    const sigma = parseFloat(btn.dataset.sigma);
                    
                    this.model.setParameters({ meanFreq: freq, sigma: sigma });
                    document.getElementById('header-freq').textContent = freq.toFixed(1) + ' Hz';
                    sigmaSlider.value = sigma;
                    document.getElementById('sigma-value').textContent = sigma.toFixed(1) + ' Hz';
                });
            });
            
            // Networks
            document.querySelectorAll('.network-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.network-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.visualization.setNetwork(btn.dataset.network);
                    document.getElementById('hud-network').textContent = btn.querySelector('.network-name').textContent.toUpperCase();
                });
            });
            
            // Action buttons
            document.getElementById('btn-start').addEventListener('click', () => {
                this.isRunning = !this.isRunning;
                const btn = document.getElementById('btn-start');
                btn.textContent = this.isRunning ? '❚❚ Halt' : '▶ Execute';
                btn.classList.toggle('running', this.isRunning);
            });
            
            document.getElementById('btn-reset').addEventListener('click', () => {
                this.model.reset();
                this.analytics.update();
                this.analytics.updateRegionList();
            });
            
            // View controls
            const viewBtns = ['view-3d', 'view-top', 'view-side', 'view-front'];
            viewBtns.forEach(id => {
                document.getElementById(id).addEventListener('click', () => {
                    viewBtns.forEach(bid => document.getElementById(bid).classList.remove('active'));
                    document.getElementById(id).classList.add('active');
                    if (id !== 'view-3d') {
                        this.visualization.setView(id.replace('view-', ''));
                    }
                });
            });
            
            document.getElementById('toggle-conn').addEventListener('click', (e) => {
                e.target.classList.toggle('active');
                this.visualization.toggleConnections(e.target.classList.contains('active'));
            });
            document.getElementById('toggle-conn').classList.add('active');
            
            document.getElementById('toggle-glitch').addEventListener('click', (e) => {
                e.target.classList.toggle('active');
                this.visualization.toggleGlitch(e.target.classList.contains('active'));
            });
        }
        
        render() {
            this.frameCount++;
            const now = performance.now();
            if (now - this.lastFpsUpdate > 1000) {
                document.getElementById('fps-display').textContent = this.frameCount;
                this.frameCount = 0;
                this.lastFpsUpdate = now;
            }
            
            if (this.isRunning) {
                for (let i = 0; i < 5; i++) {
                    this.model.step();
                }
                
                if (this.frameCount % 2 === 0) {
                    this.analytics.update();
                }
                
                if (this.frameCount % 20 === 0) {
                    this.analytics.updateRegionList();
                }
            }
            
            this.visualization.update();
            
            requestAnimationFrame(() => this.render());
        }
    }

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
        new App();
    });
    </script>
</body>
</html>
